/*** Licensed under the KARMA v.1 Law of Sharing. As others have shared freely to you, so shall you share freely back to us.* If you shall try to cheat and find a loophole in this license, then KARMA will exact your share,* and your worldly gain shall come to naught and those who share shall gain eventually above you.* In compliance with previous GPLv2.0 works of Jorg Janke, Low Heng Sin, Carlos Ruiz and contributors.* This Module Creator is an idea put together and coded by Redhuan D. Oon (red1@red1.org)*/package org.bm.process;
import java.math.BigDecimal;import java.util.ArrayList;import java.util.Date;import java.util.List;import org.adempiere.exceptions.AdempiereException;import org.bm.model.MBM_OrderManagementLine;import org.compiere.model.MInOut;import org.compiere.model.MInOutLine;import org.compiere.model.MOrder;import org.compiere.model.MOrderLine;import org.compiere.model.MWarehouse;
import org.compiere.model.Query;import org.compiere.process.ProcessInfoParameter;import org.compiere.process.SvrProcess;
import org.compiere.util.DB;
import org.compiere.util.Env;

	public class RefreshData extends SvrProcess {
	private boolean IsActive = false;
	BigDecimal totalOnHand = Env.ZERO;	BigDecimal totalBackOrders=Env.ZERO;		protected void prepare() {
		ProcessInfoParameter[] para = getParameter();
			for (ProcessInfoParameter p:para) {
				String name = p.getParameterName();
				if (p.getParameter() == null)					;
				else if(name.equals("IsActive")){
					IsActive = "Y".equals(p.getParameter());
			}
		}
	}
	protected String doIt() {
		String whereClause = "EXISTS (SELECT T_Selection_ID FROM T_Selection WHERE T_Selection.AD_PInstance_ID=? AND T_Selection.T_Selection_ID=BM_OrderManagementLine.BM_OrderManagementLine_ID)";
		ArrayList<Integer> pmlines = new ArrayList<Integer>();
		List<MBM_OrderManagementLine> lines = new Query(Env.getCtx(),MBM_OrderManagementLine.Table_Name,whereClause,get_TrxName())
		.setParameters(getAD_PInstance_ID())		.setOrderBy(MBM_OrderManagementLine.COLUMNNAME_LineNo).list();

		for (MBM_OrderManagementLine pmline:lines){
			MOrderLine orderline = new Query(Env.getCtx(),MOrderLine.Table_Name,MOrderLine.COLUMNNAME_C_OrderLine_ID+"=?",get_TrxName())					.setParameters(pmline.getC_OrderLine_ID())					.first();			if (orderline==null) //Dude, this error not meant to happen but check for it anyway				throw new AdempiereException("Strange.. Where is the ball?");						pmlines.add(pmline.get_ID());						//Days passed since DateOrdered - Days to go till DatePromised 			Date today = new Date(); 			Long diffordered = (today.getTime()-orderline.getDateOrdered().getTime())/(60*60*24*1000);			Long diffpromised = (orderline.getDatePromised().getTime()-today.getTime())/(60*60*24*1000);			pmline.setDaysSinceOrder(new BigDecimal(diffordered));			pmline.setDaysTillPromised(new BigDecimal(diffpromised));						//QtyOnHand statement and save for later calculation			pmline.setAvailable(getAllQtyOnHand(pmline.getM_Product_ID(), pmline.getM_AttributeSetInstance_ID(), get_TrxName()));			pmline.setTotalOnHand(totalOnHand);						//Check flag Is Backorders > OnHand? 			pmline.setInsufficient(totalBackOrders.compareTo(totalOnHand)>0?true:false);							//This line's back order if any and total back orders for this product (completed orders not shipped yet)			MInOutLine ioline = new Query(Env.getCtx(),MInOutLine.Table_Name,MInOutLine.COLUMNNAME_C_OrderLine_ID+"=?",get_TrxName())					.setParameters(pmline.get_ID())					.first();			if (ioline!=null){				if (ioline.getM_InOut().getDocStatus().equals(MInOut.DOCSTATUS_Completed)){					pmline.saveEx(get_TrxName());					continue;				}			}			pmline.setBackOrders(getBackOrders(pmline.getM_Product_ID()));			pmline.setTotalBackOrders(totalBackOrders);			pmline.saveEx(get_TrxName());	}	//iterate thru pmlimes ordered list, to mark deliverable is yes.	for (int i=0;i<pmlines.size();i++){		MBM_OrderManagementLine pmline = new MBM_OrderManagementLine(Env.getCtx(),pmlines.get(i),get_TrxName());		BigDecimal totalbuffer = pmline.getTotalOnHand();		if (totalbuffer.compareTo(pmline.getQtyOrdered())>0){			pmline.setReady(true);			totalbuffer.subtract(pmline.getQtyOrdered());			//update the other pmlines of same product			updateOthersTotalOnHand(totalbuffer,pmline.getBM_OrderManagement_ID(),pmline.getM_Product_ID());		} else			pmline.setReady(false);		pmline.saveEx(get_TrxName());	}	return "Processed: "+pmlines.size();	}		private void updateOthersTotalOnHand(BigDecimal totalbuffer, int m_JobProduction_ID, int m_Product_ID) { 		List<MBM_OrderManagementLine> jlines = new Query(Env.getCtx(),MBM_OrderManagementLine.Table_Name,MBM_OrderManagementLine.COLUMNNAME_BM_OrderManagement_ID+"=? AND "				+MBM_OrderManagementLine.COLUMNNAME_M_Product_ID+"=?",get_TrxName())				.setParameters(m_JobProduction_ID,m_Product_ID)				.list();		for (MBM_OrderManagementLine jline:jlines){			jline.setTotalOnHand(totalbuffer);			jline.saveEx(get_TrxName());		}	}	private String getBackOrders(int m_Product_ID) { 		String docnostring = "";		List<MOrderLine> olines = new Query(Env.getCtx(),MOrderLine.Table_Name,MOrderLine.COLUMNNAME_M_Product_ID+"=?",get_TrxName())				.setParameters(m_Product_ID)				.setOnlyActiveRecords(true)				.setClient_ID()				.list();		MOrder order = null;		StringBuilder backorders = new StringBuilder();		int bocnt = 0;		for (MOrderLine oline:olines){			if (order==null || order.get_ID()!=oline.getC_Order_ID()){				order = (MOrder) oline.getC_Order();				if (!order.getDocStatus().equals(MOrder.DOCSTATUS_Completed))					continue;				if (backorders.length()>0)					backorders=backorders.append(docnostring+" "+bocnt+" ");				docnostring=order.getDocumentNo()+":";				bocnt=0;			}			MInOutLine ioline = new Query(Env.getCtx(),MInOutLine.Table_Name,MInOutLine.COLUMNNAME_C_OrderLine_ID+"=?",get_TrxName())					.setParameters(oline.get_ID())					.first(); 			if (ioline!=null && ioline.getM_InOut().getDocStatus().equals(MInOut.DOCSTATUS_Completed))				continue; 			bocnt+=oline.getQtyOrdered().intValue();		}		backorders=backorders.append(docnostring+" "+bocnt+" ");		totalBackOrders = new BigDecimal(bocnt);		return backorders.toString();	}		private String getAllQtyOnHand(int M_Product_ID,int M_AttributeSetInstance_ID, String trxName) { 		totalOnHand = Env.ZERO;		int onHand=0;		StringBuilder available = new StringBuilder();		List<MWarehouse> whses = new Query(Env.getCtx(),MWarehouse.Table_Name,"",null)				.setOrderBy(MWarehouse.COLUMNNAME_Updated)				.list();		for (int i=0;i<whses.size();i++){			onHand=0;			MWarehouse whse = whses.get(i);			StringBuilder sql = new StringBuilder();			sql.append(" SELECT SUM(QtyOnHand) FROM M_StorageOnHand oh JOIN M_Locator loc ON (oh.M_Locator_ID=loc.M_Locator_ID)")				.append(" WHERE oh.M_Product_ID=? AND loc.M_Warehouse_ID=?");			ArrayList<Object> params = new ArrayList<Object>();			params.add(M_Product_ID);			params.add(whse.get_ID()); 			// With ASI			if (M_AttributeSetInstance_ID != 0) {				sql.append(" AND oh.M_AttributeSetInstance_ID=?");				params.add(M_AttributeSetInstance_ID);			}			BigDecimal qty = DB.getSQLValueBD(trxName, sql.toString(), params);			if (qty == null)				continue;			totalOnHand=totalOnHand.add(qty);			onHand+=qty.intValue(); 			if (i<whses.size()){				available=available.append(whse.getValue()+":"+onHand+" ");			}		}				return available.toString();

	}
}
